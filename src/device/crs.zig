// CRS
pub const CRS = struct {
    // CRS control register
    CR: packed struct(u32) {
        // SYNC event OK interrupt enable
        SYNCOKIE: u1,
        // SYNC warning interrupt enable
        SYNCWARNIE: u1,
        // Synchronization or trimming error interrupt enable
        ERRIE: u1,
        // Expected SYNC interrupt enable
        ESYNCIE: u1,
        // Reserved
        _reserved_4: u1,
        // Frequency error counter enable This bit
        // enables the oscillator clock for the frequency error
        // counter. When this bit is set, the CRS_CFGR register
        // is write-protected and cannot be
        // modified.
        CEN: u1,
        // Automatic trimming enable This bit
        // enables the automatic hardware adjustment of TRIM
        // bits according to the measured frequency error
        // between two SYNC events. If this bit is set, the TRIM
        // bits are read-only. The TRIM value can be adjusted by
        // hardware by one or two steps at a time, depending on
        // the measured frequency error value. Refer to
        // Section7.3.4: Frequency error evaluation and
        // automatic trimming for more details.
        AUTOTRIMEN: u1,
        // Generate software SYNC event This bit is
        // set by software in order to generate a software SYNC
        // event. It is automatically cleared by
        // hardware.
        SWSYNC: u1,
        // HSI48 oscillator smooth trimming These
        // bits provide a user-programmable trimming value to
        // the HSI48 oscillator. They can be programmed to
        // adjust to variations in voltage and temperature that
        // influence the frequency of the HSI48. The default
        // value is 32, which corresponds to the middle of the
        // trimming interval. The trimming step is around 67 kHz
        // between two consecutive TRIM steps. A higher TRIM
        // value corresponds to a higher output frequency. When
        // the AUTOTRIMEN bit is set, this field is controlled
        // by hardware and is read-only.
        TRIM: u6,
        // Reserved
        _reserved_14: u18,
    },
    // This register can be written only when the
    // frequency error counter is disabled (CEN bit is cleared
    // in CRS_CR). When the counter is enabled, this register is
    // write-protected.
    CFGR: packed struct(u32) {
        // Counter reload value RELOAD is the value
        // to be loaded in the frequency error counter with each
        // SYNC event. Refer to Section7.3.3: Frequency error
        // measurement for more details about counter
        // behavior.
        RELOAD: u16,
        // Frequency error limit FELIM contains the
        // value to be used to evaluate the captured frequency
        // error value latched in the FECAP[15:0] bits of the
        // CRS_ISR register. Refer to Section7.3.4: Frequency
        // error evaluation and automatic trimming for more
        // details about FECAP evaluation.
        FELIM: u8,
        // SYNC divider These bits are set and
        // cleared by software to control the division factor of
        // the SYNC signal.
        SYNCDIV: u3,
        // Reserved
        _reserved_27: u1,
        // SYNC signal source selection These bits
        // are set and cleared by software to select the SYNC
        // signal source. Note: When using USB LPM (Link Power
        // Management) and the device is in Sleep mode, the
        // periodic USB SOF will not be generated by the host.
        // No SYNC signal will therefore be provided to the CRS
        // to calibrate the HSI48 on the run. To guarantee the
        // required clock precision after waking up from Sleep
        // mode, the LSE or reference clock on the GPIOs should
        // be used as SYNC signal.
        SYNCSRC: u2,
        // Reserved
        _reserved_30: u1,
        // SYNC polarity selection This bit is set
        // and cleared by software to select the input polarity
        // for the SYNC signal source.
        SYNCPOL: u1,
    },
    // CRS interrupt and status register
    ISR: packed struct(u32) {
        // SYNC event OK flag This flag is set by
        // hardware when the measured frequency error is smaller
        // than FELIM * 3. This means that either no adjustment
        // of the TRIM value is needed or that an adjustment by
        // one trimming step is enough to compensate the
        // frequency error. An interrupt is generated if the
        // SYNCOKIE bit is set in the CRS_CR register. It is
        // cleared by software by setting the SYNCOKC bit in the
        // CRS_ICR register.
        SYNCOKF: u1,
        // SYNC warning flag This flag is set by
        // hardware when the measured frequency error is greater
        // than or equal to FELIM * 3, but smaller than FELIM *
        // 128. This means that to compensate the frequency
        // error, the TRIM value must be adjusted by two steps
        // or more. An interrupt is generated if the SYNCWARNIE
        // bit is set in the CRS_CR register. It is cleared by
        // software by setting the SYNCWARNC bit in the CRS_ICR
        // register.
        SYNCWARNF: u1,
        // Error flag This flag is set by hardware
        // in case of any synchronization or trimming error. It
        // is the logical OR of the TRIMOVF, SYNCMISS and
        // SYNCERR bits. An interrupt is generated if the ERRIE
        // bit is set in the CRS_CR register. It is cleared by
        // software in reaction to setting the ERRC bit in the
        // CRS_ICR register, which clears the TRIMOVF, SYNCMISS
        // and SYNCERR bits.
        ERRF: u1,
        // Expected SYNC flag This flag is set by
        // hardware when the frequency error counter reached a
        // zero value. An interrupt is generated if the ESYNCIE
        // bit is set in the CRS_CR register. It is cleared by
        // software by setting the ESYNCC bit in the CRS_ICR
        // register.
        ESYNCF: u1,
        // Reserved
        _reserved_4: u4,
        // SYNC error This flag is set by hardware
        // when the SYNC pulse arrives before the ESYNC event
        // and the measured frequency error is greater than or
        // equal to FELIM * 128. This means that the frequency
        // error is too big (internal frequency too low) to be
        // compensated by adjusting the TRIM value, and that
        // some other action should be taken. An interrupt is
        // generated if the ERRIE bit is set in the CRS_CR
        // register. It is cleared by software by setting the
        // ERRC bit in the CRS_ICR register.
        SYNCERR: u1,
        // SYNC missed This flag is set by hardware
        // when the frequency error counter reached value FELIM
        // * 128 and no SYNC was detected, meaning either that a
        // SYNC pulse was missed or that the frequency error is
        // too big (internal frequency too high) to be
        // compensated by adjusting the TRIM value, and that
        // some other action should be taken. At this point, the
        // frequency error counter is stopped (waiting for a
        // next SYNC) and an interrupt is generated if the ERRIE
        // bit is set in the CRS_CR register. It is cleared by
        // software by setting the ERRC bit in the CRS_ICR
        // register.
        SYNCMISS: u1,
        // Trimming overflow or underflow This flag
        // is set by hardware when the automatic trimming tries
        // to over- or under-flow the TRIM value. An interrupt
        // is generated if the ERRIE bit is set in the CRS_CR
        // register. It is cleared by software by setting the
        // ERRC bit in the CRS_ICR register.
        TRIMOVF: u1,
        // Reserved
        _reserved_11: u4,
        // Frequency error direction FEDIR is the
        // counting direction of the frequency error counter
        // latched in the time of the last SYNC event. It shows
        // whether the actual frequency is below or above the
        // target.
        FEDIR: u1,
        // Frequency error capture FECAP is the
        // frequency error counter value latched in the time of
        // the last SYNC event. Refer to Section7.3.4: Frequency
        // error evaluation and automatic trimming for more
        // details about FECAP usage.
        FECAP: u16,
    },
    // CRS interrupt flag clear register
    ICR: packed struct(u32) {
        // SYNC event OK clear flag Writing 1 to
        // this bit clears the SYNCOKF flag in the CRS_ISR
        // register.
        SYNCOKC: u1,
        // SYNC warning clear flag Writing 1 to
        // this bit clears the SYNCWARNF flag in the CRS_ISR
        // register.
        SYNCWARNC: u1,
        // Error clear flag Writing 1 to this bit
        // clears TRIMOVF, SYNCMISS and SYNCERR bits and
        // consequently also the ERRF flag in the CRS_ISR
        // register.
        ERRC: u1,
        // Expected SYNC clear flag Writing 1 to
        // this bit clears the ESYNCF flag in the CRS_ISR
        // register.
        ESYNCC: u1,
        // Reserved
        _reserved_4: u28,
    },
};

pub const CRS_BASE_ADDRESS: usize = 0x40008400;
pub const CRS_REGISTERS: *volatile CRS = @ptrFromInt(CRS_BASE_ADDRESS);
